
# This file was *autogenerated* from the file real_estate_price_investigationFinal.sage
from sage.all_cmdline import *   # import sage library

_sage_const_300000p0 = RealNumber('300000.0'); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_26 = Integer(26); _sage_const_5 = Integer(5)#load the data (masked column name version)

import pandas as pd
import sys

print "Reading data! \n"
sys.stdout.flush()

train_house_df = pd.read_csv('../trainData.csv')

print "Done reading data! \n" 

#target above/below in column 0
#data headers in row 0
#want to make 17 invariants - these will be named "target" and "inv1"..."inv16"
#for a data point (row) "house" and a invariant name "f", f(house)= entry in that row and column

# invariant numbers
"""
0 - Target
3 - Square footage
7 - $ per square foot
"""

#make House class: houses are rows (starting in row 1) from data file (collection of associated numbers)

#['TARGET', 'BEDS', 'BATHS', 'SQUARE.FEET', 'LOT.SIZE', 'YEAR.BUILT', 'DAYS.ON.MARKET', 'X..SQUARE.FEET', 'HOA.MONTH', 'LATITUDE', 'LONGITUDE', 'PROPERTY.TYPEMobile.Manufactured.Home', 'PROPERTY.TYPESingle.Family.Residential', 'PROPERTY.TYPETownhouse', 'PROPERTY.TYPEMulti.Family..2.4.Unit.', 'PROPERTY.TYPEMulti.Family..5..Unit.', 'PROPERTY.TYPEOther']

class House():
    def __init__(self, mydf, number):
        self.mydf = mydf
        self.name = "house" + str(number)
        self.number = int(number)
        #self.data = all_house_data[number]


    def is_less_equal_cutoff_number(self):
        return (int(self.mydf.iloc[self.number]["TARGET"]) == _sage_const_0 ) #means leq 300k

    def is_more_than_cutoff_number(self):
        return (int(self.mydf.iloc[self.number]["TARGET"]) == _sage_const_1 ) #means leq 300k


    def number_of_beds(self):
        return RDF(self.mydf.iloc[self.number]["BEDS"])

    def number_of_baths(self):
        return RDF(self.mydf.iloc[self.number]["BATHS"])

    def number_of_square_feet(self):
        return RDF(self.mydf.iloc[self.number]["SQUARE.FEET"])

    def lot_size(self):
        return RDF(self.mydf.iloc[self.number]["LOT.SIZE"])

    def year_built(self):
        return RDF(self.mydf.iloc[self.number]["YEAR.BUILT"])

    def days_on_market(self):
        return RDF(self.mydf.iloc[self.number]["DAYS.ON.MARKET"])

    def per_square_foot(self):
        return RDF(self.mydf.iloc[self.number]['X..SQUARE.FEET'])

    def HOA_per_month(self):
        return RDF(self.mydf.iloc[self.number]["HOA.MONTH"])

    def latitude(self):
        return RDF(self.mydf.iloc[self.number]["LATITUDE"])

    def longitude(self):
        return RDF(self.mydf.iloc[self.number]["LONGITUDE"])

    def is_mobile_home(self):
        return (int(self.mydf.iloc[self.number]["PROPERTY.TYPEMobile.Manufactured.Home"]) == _sage_const_1 )

    def is_single_family_residential(self):
        return (int(self.mydf.iloc[self.number]["PROPERTY.TYPESingle.Family.Residential"])  == _sage_const_1 )

    def is_townhouse(self):
        return (int(self.mydf.iloc[self.number]["PROPERTY.TYPETownhouse"])  == _sage_const_1 )

    def is_multi_family_2_to_4(self):
        return (int(self.mydf.iloc[self.number]["PROPERTY.TYPEMulti.Family..2.4.Unit."])  == _sage_const_1 )

    def is_multi_family_5_more(self):
        return (int(self.mydf.iloc[self.number]["PROPERTY.TYPEMulti.Family..5..Unit."])  == _sage_const_1 )

    def is_other_res_type(self):
        return (int(self.mydf.iloc[self.number]["PROPERTY.TYPEOther"])  == _sage_const_1 )

house_properties = [
        House.is_mobile_home, 
        House.is_single_family_residential, 
        House.is_townhouse, 
        House.is_multi_family_2_to_4, 
        House.is_multi_family_5_more, 
        House.is_other_res_type
        ]

train_houses = [House(train_house_df, i) for i in range(len(train_house_df))]


train_houses_below = [house for house in train_houses if house.is_less_equal_cutoff_number()]

train_houses_above = [house for house in train_houses if house.is_more_than_cutoff_number()]

# create cutoff number invariant
def cutoffInvariant(house):
    return _sage_const_300000p0 


house_invariants = [
                    House.number_of_baths, 
                    House.number_of_beds, 
                    House.lot_size, 
                    House.year_built, 
                    House.number_of_square_feet, 
                    House.days_on_market, 
                    House.per_square_foot, 
                    House.HOA_per_month, 
                    House.latitude, 
                    House.longitude, 
                    cutoffInvariant]

print "Invariants defined! \n"
sys.stdout.flush()

print "Houses loaded! \n"
sys.stdout.flush()

load("conjecturing.py")

print "conjecturing loaded ... ready to conjecture! \n"
sys.stdout.flush()

#NEEDED UTILITIES LOADING

def convert_name(name):
    for i in range(_sage_const_26 ):
        name = name.replace('({})'.format(chr(ord('a') + i)), '')
    name = name.replace(' ', '_')
    textform_first = {
        '^2': '_squared',
        '^3': '_cubed',
        '1/': 'inverse_of_'
    }
    textform = {
        '<': '_lt_',
        '<=': '_leq_',
        '>': '_gt_',
        '>=': '_geq_',
        '+': '_plus_',
        '-': '_minus_',
        '*': '_times_',
        '/': '_divided_by_',
        '^': '_to_the_power_',
        '(': 'open_bracket_',
        ')': '_close_bracket'
               }
    for op in textform_first:
        name = name.replace(op, textform_first[op])
    for op in textform:
        name = name.replace(op, textform[op])
    return name

def convert_name_back(name):
    for i in range(_sage_const_26 ):
        name = name.replace('({})'.format(chr(ord('a') + i)), '')
    # name = name.replace('_', ' ')
    textform_first = {
        '_squared': '^2',
        '_cubed': '^3',
        'inverse_of_': '1/'
    }
    textform = {
        '_lt_': '<',
        '_leq_': '<=',
        '_gt_': '>',
        '_geq_': '>=',
        '_plus_': '+',
        '_minus_': '-',
        '_times_': '*',
        '_divided_by_': '/',
        '_to_the_power_': '^',
        'open_bracket_': '(',
        '_close_bracket': ')'
               }
    for op in textform_first:
        name = name.replace(op, textform_first[op])
    for op in textform:
        name = name.replace(op, textform[op])
    return name

def convert_conjecture_names(conjectures):
    for conj in conjectures:
        conj.__name__ = convert_name(conj.__name__)

def convert_names_back(conjectures): #note the plural name(s)
    for conj in conjectures:
        conj.__name__ = convert_name_back(conj.__name__)

use_operators =  { '-1', '+1', '*2', '/2', '^2', '-()', '1/', 'sqrt', 'ln', 'log10', 'exp', '10^', 'ceil', 'floor', 'abs', '+', '*', 'max', 'min', '-', '/', '^'}

house_below_properties = []


for inv in house_invariants:
    print(inv)
    sys.stdout.flush()
    inv_of_interest = house_invariants.index(inv)
    conjs = conjecture(train_houses_below, house_invariants, inv_of_interest, operators=use_operators, upperBound=True, time=_sage_const_5 )
    convert_conjecture_names(conjs)
    house_below_properties += conjs

    conjs = conjecture(train_houses_below, house_invariants, inv_of_interest, operators=use_operators, upperBound=False, time=_sage_const_5 )
    convert_conjecture_names(conjs)
    house_below_properties += conjs

print "finished house_below invariant conjectures using TRAIN houses"

count = _sage_const_0 
for conj in house_below_properties:
    count += _sage_const_1 
    print (count, convert_name_back(conj.__name__))

sys.stdout.flush()
house_above_properties = []

for inv in house_invariants:
    print(inv)
    sys.stdout.flush()
    inv_of_interest = house_invariants.index(inv)
    conjs = conjecture(train_houses_above, house_invariants, inv_of_interest, operators=use_operators, upperBound=True, time=_sage_const_5 )
    convert_conjecture_names(conjs)
    house_above_properties += conjs

    conjs = conjecture(train_houses_above, house_invariants, inv_of_interest, operators=use_operators, upperBound=False, time=_sage_const_5 )
    convert_conjecture_names(conjs)
    house_above_properties += conjs
    
print "finished house_above invariant conjectures using TRAIN houses"

count = _sage_const_0 
for conj in house_above_properties:
    count += _sage_const_1 
    print (count, convert_name_back(conj.__name__))

sys.stdout.flush()


below_house_properties = house_properties + house_above_properties + house_below_properties
below_house_properties.append(House.is_less_equal_cutoff_number)

print "there are {} below house properties \n".format(len(below_house_properties))

below_prop = len(below_house_properties)-_sage_const_1 

below_conjs = propertyBasedConjecture(objects=train_houses, 
        properties=below_house_properties, 
        mainProperty=below_prop, 
        sufficient=True)

print "finished house_below property conjectures using TRAIN houses"

count = _sage_const_0 
for p in below_conjs:
    print count, ".", convert_name_back(p.__name__)
    count += _sage_const_1 

sys.stdout.flush()

above_house_properties = house_properties + house_above_properties + house_below_properties
above_house_properties.append(House.is_more_than_cutoff_number)

print "there are {} above house properties \n".format(len(above_house_properties))

above_prop = len(above_house_properties)-_sage_const_1 

above_conjs = propertyBasedConjecture(objects=train_houses, 
        properties=above_house_properties, 
        mainProperty=above_prop, 
        sufficient=True)

print "finished house_above property conjectures using TRAIN houses"

count = _sage_const_0 
for p in above_conjs:
    print count, ".", convert_name_back(p.__name__)
    count += _sage_const_1 

sys.stdout.flush()




